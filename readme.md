# 정보 처리 기사 

## 11장. 응용 SW 기초 기술 활용

---

### Section 163 운영체제의 개념

---



#### 운영체제

* `운영체제` : 컴퓨터 시스템 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임 (자원: CPI, RAM, ROM, file 등)
* 사용자와 하드웨어 간의 인터페이스로 동작하는 시스템 소프트웨어

* Windows, UNIX, LINUX, MacOS, MS-DOS



#### 운영체제의 목적

* `처리 능력` : 일정 시간 내에 시스템이 처리하는 일의 양
* `반환 시간` : 시스템에 작업을 의뢰한 시간부터, 처리가 완료될 때 까지 걸린 시간
* `사용 가능도` : 시스템을 사용할 필요가 있을 때, 즉시 사용 가능한 정도
* `신뢰도` : 시스템이 주어진 문제를 정확하게 해결하는 정도



#### 운영체제의 기능

* 프로세서(처리기, Processor), 기억장치(주기억장치, 보조기억장치), 입,출력장치, 파일 및 정보 등의 자원 관리
* 자원을 효율적으로 관리하기 위한 스케쥴링 기능 제공
* 사용자와 하드웨어 간의 인터페이스 제공(GUI)
* 시스템의 각종 하드웨어와 네트워크를 관리 및 제어
* 데이터 관리 및 데이터 및 자원의 공유 기능 제공



---

### Section 164 운영 체제의 종류

---



#### Windows 의 특징

* `그래픽 사용자 인터페이스(GUI)`
  * 키보드 명령어가 아닌 마우스 사용
* `선점형 멀티태스킹`
  * 동시에 여러개의 프로그램을 실행하는 멀티태스킹을 하면서 운영체제가 각 작업의 CPI 이용 시간을 제어
  * 문제 발생시, 해당 프로그램을 강제 종료시키고 시스템 자원 반환
* `PnP(Plug and Play)`
  * 컴퓨터 시스템에 새 하드웨어를 설치했을때, 시스템 환경을 운영체제가 자동으로 구성해주는 기능
* `OLE(Object Linking and Embedding)`
  * 다른 응용 프로그램에서 작성된 문자나 그림 등의 개체를 현재 작성 중인 문서에 자유롭게 연결하거나 삽입하여 편집 할 수 있음 (ex, 그림 to 그림판)
* `255자의 긴 파일명`
  * 문자 및 공백을 사용하여 255자까지 파일 이름 지정 가능
* `Single-User 시스템`
  * 컴퓨터 한 대를 한 사람만이 독점해서 사용함



#### UNIX

* AT&T, MIT, GE이 공동 개발한 운영체제 
* 시분할 시스템(Time Sharing)을 위해 설계된 대화식 운영체제
* 소스가 개방된 Open System

* 대부분이 C언어로 작성되어 있어 이식성이 높으며 호환성이 높음
* 다중 사용자, 다중 작업 지원
* Tree 구조의 파일 시스템



#### UNIT 시스템의 구성

* 커널 (가장 핵심적)
  * 하드웨어를 보호, 프로그램과 하드웨어 간의 인터페이스
  * 프로세스 관리, 기억장치 관리, 파일 관리, 입 출력 관리, 프로세스간 통신, 데이터 전송 및 변환

* 쉘
  * 사용자의 명령어를 인식하여 프로그램을 호출하고 명령을 수행하는 명령어 해석기
  * 시스템과 사용자 간의 인터페이스
* 유틸리티 프로그램
  * 일반 사용자가 작성한 응용 프로그램을 처리하는데 사용함
  * DOS에서의 외부 명령어에 해당됨



#### LINUX

* 리누스 토발즈가 UNIX를 기반으로 개발한 운영체제
* 프로그램 소스 코드가 무료로 공개, 
* 다양한 플랫폼에 설치 및 사용 가능, 재배포 가능
* UNIX와 비슷, 호환 잘 됨



#### MacOS

* Apple이 UNIX를 기반으로 개발한 운영체제



#### Android

* 구글에서 개발한 리눅스 커널 기반의 개방형 모바일 운영체제
* Open Source Software
* 자바 및 코틀린으로 어플리케이션 작성
* 휴대용 장치에서 주로 사용



#### iOS

* Apple이 UNIX 기반으로 개발한 모바일 운영체제



---

### Section 165 기억장치 관리

---



#### 기억장치의 관리 전략

* 기억장치의 관리 전략은 보조기억장치의 프로그램이나 데이터를 주기억장치에 적재시키는 시기, 적재 위치 등을 지정하여 한정된 주기억장치의 공간을 효율적으로 사용하기 위한 것.
* 종류
  * `반입(Fetch) 전략`
  * `배치(Placement) 전략`
  * `교체(Replacement) 전략`



#### 반입(Fetch) 전략													* 주 기억장치 적재 전에는 어디에 있는가?

* 보관중인 프로그램이나 데이터를 언제 주기억장치로 적재할 것인지를 결정하는 전략
  * `요구 반입`
    * 실행중인 프로그램이 특정 프로그램이나 데이터 등의 참조를 요구할 때 적재하는 방법
  * `예상 반입`
    * 실행중인 프로그램에 의해 참조될 프로그램이나 데이터를 미리 예상하여 적재하는 방법



#### 배치(Placement) 전략

* 새로 반입되는 프로그램이나 데이터를 주기억장치의 어디에 위치 시킬 것인지를 결정하는 전략

  * `최초 적합`
    * 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 첫번째 분할 영역에 배치
  * `최적 적합`
    * 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화를 가장 작게 남기는 분할 영역에 배치
      * 단편화: 주기억장치의 분할된 영역에 프로그램이나 데이터를 할당할 경우, 분할된 영역이 프로그램이나 데이터보다 작거나 커서 생기는 빈 기억 공간

  * `최악 적합`
    * 프로그램이나 데이터가 들어갈 수 있는 크기의  빈 영역 중에서 단편화를 가장 많이 남기는 분할 영역에 배치시키는 방법



#### 교체(Replacement) 전략

* 주기억장치의 모든 영역이 이미 사용중인 상태에서 새로운 프로그램이나 데이터를 주기억장치에 배치시키려고 할 때, 이미 사용되고 있는 영역 중 어느 영역을 교체하여 사용할 것인지 결정
* 종류 
  * `FIFO`, `OPT`, `LRU`, `LFU`, `NUR`, `SCR`



---

#### Section 166 주기억장치 할당 기법

---



#### 주기억장치 할당

* 주 기억장치 할당 기법은 프로그램이나 데이터를 실행시키기 위해 주기억장치에 어떻게 할당할 것인지에 대한 내용이다.
  * `연속 할당 기법` 
    * 프로그램을 주기억장치에 연속으로 할당하는 기법
    * ex) 단일 분할 할당 기법, 다중 분할 할당 기법
  * `분산 할당 기법` (가상 기억장치의 내용을 주기억장치에 할당하기 위한 기법, 가상 기억장치 관리 기법)
    * 프로그램을 특정 단위의 조각으로 나누어 주기억장치 내에 분산하여 할당하는 기법
    * ex) 페이징 기법, 세그먼테이션 기법



#### 단일 분할 할당 기법

* 주기억 장치를 운영체제 영역과 사용자 영역으로 나누어 한순간에는 오직 한 명의 사용자만이 주기억장치의 사용자 영역을 사용하는 기법
* 가장 단순한 기법
* 경계 레지스터 이용 => 운영체제 보호, 사용자 영역만을 이용 (사용자 프로그램이 운영체제 영역에 접근하지 못하도록 보호하는 레지스터)
* 프로그램의 크기가 작을 경우 사용자 영역이 낭비 될 수 있다.
* 종류
  * `오버레이(Overlay) 기법`
    * 주기억장치보다 큰 사용자 프로그램을 실행하기 위한 기법
  * `스와핑 기법`
    * 하나의 프로그램 전체를 주기억장치에 할당하여 사용하다 필요에 따라 다른 프로그램과 교체하는 기법



#### 다중 분할 할당 기법

* `고정 분할 할당 기법 (정적 할당 기법)`
  * 프로그램을 할당하기 전에 운영체제가 주기억장치의 사용자 영역을 **여러개의 고정된 크기로 분할**하고 준비상태 큐에서 준비중인 프로그램을 각 영역에 할당하여 수행하는 기법
* `가변 분할 할당 기법 (동적 할당 기법)`
  * 주기억장치를 미리 분할해 놓지 않고 프로그램을 주기억장치에 적재하면서 **필요한 만큼의 크기로 영역을 분할하는 기법**
  * 고정 분할 할당 기법의 단편화를 줄이기 위해 사용



---

### Section 167 가상기억장치 구현 기법

---

#### 가상기억장치															?보조 기억 장치를 주기억장치처럼 사용할 수 있으면 왜 안사용하나?

* `가상기억장치` : 보조기억장치의 일부를 주기억장치처럼 사용하는 것
  * 용량이 작은 주기억장치를 마치 큰 용량을 가진 것처럼 사용하는 기법이다.

* 프로그램을 여러 개의 작은 블록* 단위로 나누어서 가상기억장치에 보관해놓고, 프로그램 실행 시 요구되는 블록만 주기억장치에 불연속적으로 할당하여 처리 (블록: 보조기억장치와 주기억장치 간에 전송되는 데이터의 최소 다누이)
* 주기억장치의 이용률과 다중 프로그래밍의 효율을 높일 수 있다.
* 블록 단위로 나누어 사용하므로 연속 할당 방식에서 발생할 수 있는 단편화를 해결할 수 있다.
* ex) 페이징 기법, 세그먼테이션 기법



#### 페이징(Paging기법) 

* 물리적 크기로 나누어서 적재

* 가상 기억장치에 보관되어 있는 프로그램과 주기억장치의 영역을 동일한 크기로 나눈 후 나눠진 프로그램을 동일하게 나눠진 주기억장치의 영역에 적재시켜 실행
* 프로그램을 일정한 크기로 나눈 단위를 페이지(Page)라고 하고 페이지 크기로 일정하게 나누어진 주기억장치의 단위를 페이지 프레임이라고 한다.
* 외부 단편화는 발생하지 않으나 내부 단편화는 발생할 수 있다. (마지막 Page에 빈 공간 발생 할 수 있다.)
* 주소 변환*을 위해서 페이지의 위치 정보를 가지고 있는 페이지 맵 테이블이 필요하다.
* 페이지 맵 테이블 사용으로 비용이 증가하고, 처리 속도가 감소된다.



#### 세그먼트(Segmentation)기법

* 논리적 크기로 나누어서 적재

* 가상기억장치에 보관되어 있는 프로그램을 다양한 크기의 논리적인 단위로 나눈 후 주기억장치에 적재시켜 실행시키는 기법
* 논리적인 크기로 나눈 단위를 (Segment)라고 하며, 각 세그먼트는 고유한 이름과 크기를 갖는다.
* 기억공간을 절약하기 위해 사용
* 세그먼트 존재 위치 정보를 가지고 있는 세그먼트 맵 테이블이 필요하다
* 내부 단편화는 발생하지 않으나, 외부 단편화가 발생 할 수 있다.



---

### Section 168 페이지 교체 알고리즘

---



#### 페이지 교체 알고리즘

* 페이지 부재 (Page Fault)가 발생하면 가상기억장치에서 필요한 페이지를 찾아 주기억장치에 적재해야 하는데, 이때 주기억장치의 모든 페이지 프레임이 사용중이면 어떤 페이지 프레임을 선택하여 교체할 것인지를 결정하는 기법
  * 페이지부재 : CPU가 액세스한 가상 페이지가 주기억장치에 없는 경우, 해당 페이지를 디스크에서 주기억장치로 가져와야한다.

* Ex) `OPT`, `FIFO`, `LRU`, `LFU`, `NUR`, `SCR`



#### OPT (OPTimal replacement, 최적 교체)

* 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체하는 기법이다.
* 페이지 부재 횟수가 가장 적게 발생하는 가장 효율적인 알고리즘이다.



#### FIFO (First In First Out)

* 각 체이지가 주기억장치에 적재될 때마다 그때의 시간을 기억시켜 **가장 먼저 들어와서 가장 오래 있었던 페이지를 교체**
* 이해하기 쉽고, 프로그래밍 및 설계가 간단하다.



#### LRU (Least Recently Used)

* 최근에 **가장 오랫동안 사용하지 않은 페이지를 교체**하는 기법

* 각 페이지마다 Counter나 Stack을 두어 가장 오랫동안 사용하지 않은 페이지 교체



#### LFU (Least Frequently Used)

* **사용 빈도가 가장 적은 페이지를 교체**
* 활발하게 사용되는 페이지는 사용 횟수가 많아 교체되지 않고 사용



#### NUR (Not Used Recently)

* **최근에 가장 오랫동안 사용되지 않은 페이지를 교체**
* LRU에서 나타나는 시간적인 오버헤드를 줄일 수 있다.
* 최근 사용여부 판단을 위해 참조비트와 변형비트 사용
  * 0,0 => 0,1 => 1,0 => 1,1 순으로 교체



#### SCR (Second Chance Replacement, 2차 기회 교체)

* **가장 오랫동안 주 기억장치에 있던 페이지 중 자주 사용되는 페이지의 교체를 방지**하기 위한 기법
* FIFO의 단점 보완에 사용



---

### Section 169 가상기억장치 기타 관리 사항

---



#### 페이지 크기

* 페이징 기법을 사용하면 프로그램을 페이지 단위로 나누게 되는데 페이지의 크기에 따라 시스템에 미치는 영향이 다르다.
* 페이지 크기가 작을 경우
  * **페이지 단편화 감소**, 페이지 당 주기억장치 이동 시간 줄어듦
  * 불필요한 내용이 주기억장치에 적재될 확률 줄어듦 => **효율적인 워킹셋 유지**
  * 페이지 맵 테이블의 크기가 커지고 매핑 속도가 느려짐
  * 디스크 접근 횟수가 많아져서 전체적인 입 출력 시간 증가
* 페이지 크기가 클 경우
  * 페이지 맵 테이블의 크기가 작아지고 **매핑 속도 빨라짐**
  * 디스크 접근 횟수가 줄어들어 전체적인 **입 출력의 효율성이 증가됨**
  * 페이지 단편화가 증가되고, 한개의 페이지를 주기억장치로 이동시키는 시간이 늘어남



#### Locality

* `Locality` : 프로세스가 실행되는 동안 주기억장치를 참조할 때 일부 페이지만 집중적으로 참조하는 성질이 있다.
* 스래싱을 방지하기 위한 워킹셋 이론의 기반이 되었다. (스래싱 : 자원 부족으로 인한 작업 불능 상태)
* 가상기억장치 관리와 캐시 메모리 시스템의 이론적인 근거
* Locality의 종류
  * `시간 구역성`*
    * 프로세스가 실행되면서 하나의 페이지를 일정시간동안 집중적으로 액세스 하는 현상
    * 하나의 페이지를 참조하면 한동안 해당 페이지 참조 가능성 증가
  * `공간 구역성`*
    * 프로세스 실행 시 일정 위치의 페이지를 집중적으로 액세스 하는 현상 
    * 하나의 페이지를 참조하면 근처 페이지들 참조 가능성 증가



#### 워킹 셋 (Working Set)

* 프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합 (Locality 특징을 이용)
* 자주 참조되는 워킹셋을 주기억장치에 상주시킴으로써 페이지 부재 및 페이지 교체 빈도 감소



#### 스레싱 (Thrashing)

* 프로세스의 처리 시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상
* 자주 페이지 부재가 발생함으로써 나타남 => 전체 시스템의 성능 저하
* 다중 프로그래밍의 정도가 높아짐에 따라 CPU의 이용률은 어느 특정 시점까지는 높아지지만, 너무 커지면 쓰레싱 발생



---

### Section 170 프로세스의 개요

---



#### 프로세스

* 프로세스는 일반적으로 프로세서에 의해 처리되는 사용자 프로그램, 시스템 프로그램, 즉 **실행중인 프로그램**을 의미한다.

  * PCB를 가진 프로그램 
  * 실기억장치에 저장된 프로그램
  * 프로세서가 할당되는 실체, 디스패치가 가능한 단위
  * 프로시저가 활동 중인 것 (*프로시저 : 한 프로그램은 여러 개의 작은 프로그램으로 분할될 수 있는데, 이 때, 분할된 작은 프로그램)
  * 비동기적 행위를 일으키는 주체 (*비동기적 행위: 다수의 프로세스가 서로 규칙적이거나 연속적이지 않고 독립적으로 실행)
  * 지정된 결과를 얻기위한 일련의 계통적 동작

  * 목적 또는 결과에 따라 발생되는 사건들의 과정
  * 운영체제가 관리하는 실행 단위



#### PCB(Process Control Block, 프로세스 제어 블록)

* `PCB`: 운영체제가 프로세스에 대한 중요한 정보를 저장해 놓는 곳
* 각 프로세스는 생성될 때마다 고유의 PCB 생성, 프로세스 완료시 제거
* PCB 내에 저장되는 정보
  * 프로세스의 상태
  * 포인터 (*부모 프로세스, 자식 프로세스, 위치 메모리, 자원)
  * 프로세스 id
  * 스케줄링 및 프로세스의 우선 순위
  * CPU 레지스터 정보
  * 주기억장치 관리 정보
  * 입 출력 상태 정보
  * 계정 정보



#### 프로세스 상태 전이

* `프로세스 상태 전이` : 프로세스가 시스템 내에 존재하는 동안 프로세스의 상태가 변하는 것 의미

  | 상태                    | 내용                                                         |
  | ----------------------- | ------------------------------------------------------------ |
  | 제출(Submit)            | 작업을 처리하기 위해 사용자가 작업을 시스템에 제출한 상태    |
  | 접수(Hold)              | 제출된 작업이 스풀 공간인 디스크의 할당 위치에 저장된 상태   |
  | 준비(Ready)             | 프로세스가 프로세서를 할당받기 위해 기다리고 있는 상태       |
  | 실행(Run)               | 준비상태 큐에 있는 프로세스가 프로세서를 할당 받아 실행되는 상태 |
  | 대기(Wait), 블록(Block) | 프로세스에 입출력 처리가 필요하면 현재 실행 중인 프로세스가 중단되고 입출력 처리 완료 시 까지 대기 |
  | 종료(Terminate, Exit)   | 프로세스의 실행이 끝나고 프로세스 할당이 해제된 상태         |



#### 프로세스 상태 전이 관련 용어

* | 용어               | 내용                                                         |
  | ------------------ | ------------------------------------------------------------ |
  | Dispatch           | 준비 상태에서 대기하고 있는 프로세스 중 하나가 프로세서를 할당받아 실행 상태로 전이되는 과정 |
  | Wake up            | 입출력 작업이 완료되어 프로세스가 대기 상태에서 준비 상태로 전이되는 과정 |
  | Spooling           | 입 출력 장치의 공유 및 느린 처리속도를 보완하기 위해, 한번에 입출력 하기위해 디스크에 저장하는 과정 |
  | Traffic Controller | 프로세스의 상태에 대한 조사와 통보 담당                      |



#### 스레드(Thread)

* `스레드` : 시스템의 여러 자원을 할당받아 실행하는 프로그램의 단위 or 프로세스 내에서의 작업 단위
* 하나의 프로세스에 하나의 스레드가 존재하는 경우 단일 스레드, 하나 이상의 스레드가 존재하는 경우 다중 스레드
* 프로세스의 일부 특성을 갖고 있기 때문에 경량 프로세스라고도 한다.
* 스레드 기반 시스템에서 독립적인 스케줄링의 최소단위



---

### Section 171 스케줄링

---



#### 스케줄링

* `스케줄링` : 프로세스가 생성되어 실행될 때 필요한 **시스템의 여러 자원을 해당 프로세스에게 할당하는 작업**
* 프로세스가 생성되어 완료될 때 까지 프로세스는 여러 종류의 스케줄링 과정을 거치게 된다.
* 종류
  * 장기 스케줄링
    * 어떤 프로세스가 시스템의 자원을 차지할 수 있도록 할 것인가를 결정하여 준비상태 큐로 보내는 작업
  * 중기 스케줄링
    * 어떤 프로세스들이 CPU를 할당받을 것인지를 결정하는 작업
  * 단기 스케줄링
    * 프로세스가 실행되기 위해 CPU를 할당받는 시기와 특정 프로세스를 지정하는 작업



#### 스케줄링의 목적

* | 목적                  | 내용                                                         |
  | --------------------- | ------------------------------------------------------------ |
  | 공정성                | 모든 프로세스에 공정하게 할당함                              |
  | 처리율 증가           | 단위 시간당 프로세스를 처리하는 비율을 증가시킴              |
  | CPU 이용률 증가       | CPU가 순수하게 프로세스를 실행하는 데 사용되는 시간 비율을 증가시킴 |
  | 우선순위 제도         | 우선순위가 높은 프로세스를 먼저 실행함                       |
  | 오버헤드 최소화       | 오버헤드를 최소화함                                          |
  | 응답 시간 최소화      | 작업을 지시하고, 반응하기 시작하는 시간을 최소화함           |
  | 반환 시간 최소화      | 프로세스 제출 시간부터 실행 완료까지 걸리는 시간 최소화      |
  | 대기 시간 최소화      | 프로세스가 준비 상태 큐에서 대기하는 시간을 최소화함         |
  | 균형 있는 자원의 사용 | 메모리, 입 출력장치 등의 자원을 균형 있게 사용함             |
  | 무한 연기 회피        | 자원을 사용하기 위해 무한정 연기되는 상태를 회피함           |



#### 비선점 (Non-preemptive) 스케줄링

* 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄링 기법이다.
* 프로세스가 CPU를 할당받으면 해당 프로세스가 완료될 때까지 CPU를 사용한다.
* 응답 시간 예측 용이, 일괄 처리방식에 적합
* ex) FCFS, SJF, 우선순위, HRN, 기한부



#### 선점 (Preemptive) 스케줄링

* 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링 기법

* 우선순위가 높은 프로세스를 빠르게 처리할 수 있다.

* 빠른 응답시간을 요구하는 대화식 시분할 시스템에 사용된다.

* 많은 오버헤드 발생 (오버헤드: 처리를 하기 위해 들어가는 간접적인 처리 시간, 메모리)

* ex) Round Robin, SRT, 선점 우선순위, 다단계 큐, 다단계 피드백 큐

  

---

### Section 172 주요 스케줄링 알고리즘

---



#### FCFS (First Come First Service, 선입 선출)

* 준비상태 큐에 도착한 순서에 따라 차례로 CPU를 할당하는 기법
* 가장 간단한 알고리즘
  * 대기 시간 : 프로세스가 대기한 시간, 바로 앞 프로세스까지의 진행시간
  * 반환 시간: 프로세스의 대기 시간과 실행시간의 합



#### SJF (Shortest Job First, 단기 작업 우선)

* 준비상태 큐에서 기다리고 있는 프로세스들 중에서 실행 시간이 가장 짧은 프로세스에게 먼저 CPU를 할당하는 기법
* 가장 적은 평균 대기 시간을 제공하는 최적 알고리즘



#### HRN (Highest Response-ratio Next)

* 대기 시간과 서비스(실행) 시간을 이용하는 기법
* 실행 시간이 긴 프로세스에 불리한 SJF 기법을 보완하기 위한 것
* 우선순위를 계산하여 그 숫자가 가장 높은 것부터 낮은 순으로 우선순위가 부여된다.
* 우선순위 계산식
  * (대기시간 + 서비스 시간) / 서비스 시간



---

### Section 173 환경 변수

---



#### 환경 변수

* `환경변수` : 시스템 소프트웨어의 동작에 영향을 미치는 동적인 값들의 모임
* 변수명, 값으로 구성
* 시스템의 기본 정보 저장
* 자식 프로세스에 상속
* 시스템 전반에 걸쳐 적용되는 시스템 환경 변수와 사용자 계정 내에서만 적용되는 사용자 환경 변수로 구분된다.
  * `시스템 환경 변수` : 적용되는 범위가 모듈이나 실행 프로세스 내인 경우, 내부 환경 변수, 모듈 외인 경우 외부 환경 변수



#### Windows의 주요 환경 변수

* Windows에서 환경 변수 사용시 양옆에 % 붙여야 한다.

* set을 입력하면 모든 환경 변수 및 값을 출력한다

  | 환경 변수        | 용도                                        |
  | ---------------- | ------------------------------------------- |
  | %ALLUSERPROFILE% | 모든 사용자의 프로필이 저장된 폴더          |
  | %APPDATA%        | 설치된 프로그램의 필요 데이터가 저장된 폴더 |
  | %COMSPEC%        | 기본 명령 프롬포트로 사용할 프로그램명      |
  | %HOMEDRIVE%      | 로그인한 계정의 정보가 저장된 드라이브      |
  | %HOMEPATH%       | 로그인한 계정의 기본 폴더                   |
  | %LOGONSERVER%    | 로그인한 계정이 접속한 서버명               |
  | %PATH%           | 실행 파일을 찾는 경로                       |
  | %PATHEXT%        | cmd에서 실행할 수 있는 파일의 확장자 목록   |
  | %PROGRAMFILES%   | 기본 프로그램의 설치 폴더                   |
  | %SYSTEMDRIVE%    | Windows가 부팅된 드라이브                   |
  | %SYSTEMROOT%     | 부팅된 운영체제가 들어있는 폴더             |
  | %TEMP% OR %TMP%  | 임시 파일이 저장되는 폴더                   |
  | %USERDOMAIN%     | 로그인한 시스템의 도메인 명                 |
  | %USERNAME%       | 로그인한 계정 이름                          |
  | %USERPROFILE%    | 로그인한 유저의 프로필이 저장된 폴더명      |



#### UNIX / LINUX의 주요 환경 변수

* UNIX나 LINUX에서는 환경변수 앞에 $붙여야 한다.

* set, env, printenv, setenv 중 하나를 입력하면 모든 환경변수 출력

  | 환경변수 | 용도                                                 |
  | -------- | ---------------------------------------------------- |
  | $DISPLAY | 현재 X 윈도* 디스플레이 위치 (X 윈도: UNIX 기반 GUI) |
  | $HOME    | 사용자의 홈 디렉터리                                 |
  | $LANG    | 프로그램 사용 시 기본적으로 지원되는 언어            |
  | $MAIL    | 메일을 보관하는 경로                                 |
  | $PATH    | 실행 파일을 찾는 경로                                |
  | $PS1     | 쉘 프롬포트 정보                                     |
  | $PWD     | 현재 작업하는 디렉터리                               |
  | $TERM    | 로긴 터미널 타입                                     |
  | $USER    | 사용자의 이름                                        |



---

### Section 174 운영체제 기본 명령어     (* 외울거 많음!)

---



#### Windows 기본 명령어

* | 명령어 | 기능                                        |
  | ------ | ------------------------------------------- |
  | DIR    | 현재 디렉터리의 파일 목록 표시              |
  | COPY   | 파일 복사                                   |
  | DEL    | 파일 삭제                                   |
  | TYPE   | 파일의 내용 표시                            |
  | REN    | 파일의 이름 변경                            |
  | MD     | 디렉터리 생성                               |
  | CD     | 동일한 드라이브에서 디렉터리의 위치 변경    |
  | CLS    | 화면의 내용 지움                            |
  | ATTRIB | 파일의 속성 변경                            |
  | FIND   | 파일에서 문자열을 찾음                      |
  | CHKDSK | 디스크 상태 점검                            |
  | FORMAT | 디스크 표면을 트랙과 섹터로 나누어 초기화함 |
  | MOVE   | 파일을 이동함                               |



#### UNIX/LINUX 기본 명령어

* | 명령어  | 기능                                           |
  | ------- | ---------------------------------------------- |
  | cat     | 파일 내용 화면에 표시                          |
  | cd      | 디렉터리의 위치 변경                           |
  | chmod   | 파일의 보호모드 설정, 파일의 사용 허가 지정    |
  | chown   | 파일 소유자와 그룹을 변경함                    |
  | cp      | 파일 복사                                      |
  | rm      | 파일 삭제                                      |
  | find    | 파일 찾음                                      |
  | fsck    | 파일 시스템 검사 및 보수                       |
  | kill    | PID프로세스 고유 번호를 이용하여 프로세스 종료 |
  | fork    | 새로운 프로세스 생성                           |
  | killall | 프로세스의 이름을 이용하여 프로세스 종료       |
  | ls      | 현재 디렉터리 파일 목록 표시                   |
  | mkdir   | 디렉터리 생성                                  |
  | rmdir   | 디렉터리 삭제                                  |
  | mv      | 파일 이동                                      |
  | ps      | 현재 실행중인 프로세스 표시                    |
  | pwd     | 현재 작업중인 디렉터리 경로를 화면에 표시함    |
  | top     | 시스템의 프로세스와 메모리 사용 현황을 표시함  |
  | who     | 현재 시스템에 접속해 있는 사용자 표시          |



---

### Section 175 인터넷

---



#### 인터넷

* `인터넷`: TCP/IP 프로토콜을 기반으로 전세계 수많은 컴퓨터와 네트워크들이 연결된 광범위한 컴퓨터 통신망
* 인터넷에 연결된 모든 컴퓨터는 고유한 IP주소를 갖는다.



#### IP 주소 (Internet Protocol Address)

* `IP 주소` : 인터넷에 연결된 모든 컴퓨터 자원을 구분하기 위한 고유한 주소
* 8비트씩 4부분, 총 32비트
* IP주소는 네트워크 부분의 길이에 따라 다음과 같이 A클래스에서 E클래스까지 총 5단계로 이루어져 있다.
  * A Class : 국가나 대형 통신망에 사용 (0 ~ 127로 시작) | 네트워크 부분 8비트, 호스트 부분 24비트
  * B Class : 중대형 통신망에 사용 (128 ~ 191로 시작) | 네트워크 부분 16비트, 호스트 부분 16비트
  * C Class : 소규모 통신망에 사용 (192 ~ 223로 시작) | 네트워크 부분 24비트, 호스트 부분 8비트
  * D Class : 멀티 캐스트용으로 사용 (224 ~ 239로 시작) (멀티 캐스트 : 한명 이상의 송신자들이 특정한 한명 이상의 수신자에게 데이터 전송)
  * E Class : 실험적 주소, 공용되지 않음



#### 서브네팅 (Subnetting)

* `서브네팅` : 할당된 네트워크 주소를 다시 여러개의 작은 네트워크로 나누어 사용하는 것
* 4바이트의 IP 주소 중 네트워크 주소와 호스트 주소를 구분하기 위한 비트를 서브넷 마스크(Subnet Mask)라고 함
  * 서브넷 마스크를 변경하여 네트워크 주소를 여러개로 분할하여 사용한다.
  * 서브넷 마스크는 각 클래스 별로 다르게 사용된다.



#### IPv6 (Internet Protocol version 6)

* `IPv6` : 현재 사용하고 있는 IP 주소 체계인 IPv4의 주소 부족 문제를 해결하기 위해 개발
* 128비트이 긴 주소를 사용하여 주소 부족 문제를 해결할 수 있다.
* IPv4에 비해 자료 전송 속도가 빠르다
* 인증성, 기밀성, 데이터 무결성의 지원으로 보안 문제를 해결할 수 있다.
  * 인증성 : 사용자의 식별과 접근 권한 검증
  * 기밀성 : 시스템 내의 정보와 자원은 인가된 사용자에게만 접근 허용
  * 무결성 : 시스템 내의 정보는 인가된 사용자만 수정 가능
* 주소의 확장성, 융통성, 연동성이 뛰어남
* 실시간 흐름 제어로 향상된 멀티미디어 기능 지원
* 패킷 크기를 확장할 수 있으므로 패킷 크기 제한 없음
* 기본 헤더 뒤에 확장 헤더를 더함으로써 더욱 다양한 정보의 저장이 가능 => 네트워크 기능 확장 용이
  * 헤더 : 패킷 전송 시 제일 앞에 배치되는 영역 (IP 주소 버전, 인증 정보, 패킷 정보, 출발 주소, 도착주소 등의 다양한 정보 포함)
* IPv4와 호환이 뛰어나다



#### IPv6의 구성

* 16비트씩 8부분, 128비트로 구성
* 각 부분을 16진수로 표현, : 으로 구분
* 세가지 주소체계
  * `유니캐스트` : 단일 송신자와 단일 수신자 간의 통신 (1대1 통신에 사용)
  * `멀티캐스트` : 단일 송신자와 다중 수신자 간의 통신 (1대다 통신에 사용)
  * `애니캐스트` : 단일 송신자와 가장 가까이 있는 단일 수신자 간의 통신 (1대1 통신에 사용)



#### 도메인 네임 (Domain Name)

* `도메인 네임` : 숫자로 된 IP 주소를 사람이 이해하기 쉬운 문자 형태로 표현한 것
* 호스트 컴퓨터 이름, 소속 기관이름, 소속 기관의 종류, 소속 국가명 순으로 구성, 왼쪽에서 오른쪽으로 갈수록 상위 도메인 의미
  * ex) www, sinagong, co, kr
* 문자 도메인을 DNS 사용하여 컴퓨터가 이해할 수 있는 IP주소로 변환



---

### Section 176 OSI 참조 모델													(*아직 이해 못함 / 예시 필요)

---



#### OSI (Open System Interconnection) 참조 모델

* `OSI 참조모델` : 다른 시스템 간의 원활한 통신을 위해 ISO(국제표준화기구)에서 제안한 통신 규약(Protocol)이다.
* 특정 시스템에 대한 프로토콜의 의존도를 줄이고 확장성을 고려해 보편적인 개념과 용어를 사용하여 통신망 논리 구조 규정
* OSI 7계층은 1 ~ 3 계층을 하위 계층, 4 ~ 7 계층을 상위 계층이라고 한다.
  * 하위 계층 : `물리계층` => `데이터 링크 계층` => `네트워크 계층`
  * 상위 계층 : `전공 계층` => `세션 계층` => `표현 계층` => `응용 계층`



#### 물리 계층 (Physical Layer)

* 전송에 필요한 두 장치간의 실제 접속과 절단 등 기계적, 전기적, 기능적, 절차적 특성에 대한 규칙을 정의 한다. 
* 물리적 전송 매체와 전송 신호 방식을 정의한다.
* 관련 장비 : 리피터 허브



#### 데이터 링크 계층 (Data Link Layer)

* 두 개의 인접한 개방 시스템들 간에 신뢰성 있고 효율적인 정보 전송을 할 수 있도록 시스템 간 연결 설정과 유지 및 종료를 담당
* 송신 측과 수신 측의 속도 차이 해결을 위한 흐름 제어 기능을 한다.
* 프레임의 시작과 끝을 구분하기 위한 프레임의 동기화 기능을 한다.
* 오류의 검출과 회복을 위한 오류 제어 기능을 한다.
* 프레임의 순서적 전송을 위한 순서 제어 기능을 한다.
* 관련 장비 : 랜카드, 브리지, 스위치



#### 네트워크 계층 (Network Layer)

* 개방 시스템들 간의 네트워크 연결을 관리하는 기능과 데이터의 교환 및 중계 기능 
* 네트워크 연결의 설정, 유지, 해제 기능
* 경로 설정, 데이터 교환 및 중계, 트래픽 제어, 패킷 정보 전송 수행
* IP 표준
* 관련 장비 : 라우터



#### 전송 계층

* 논리적 안정과 균일한 데이터 전송 서비스를 제공함으로써 종단 시스템 (End-to-End) 간에 투명한 데이터 전송을 가능하게 한다.
* 하위 3계층과 상위 3계층의 인터페이스
* 종단 시스템 간의 전송 연결 설정, 데이터 전송, 연결 해제 기능
* 주소 설정, 다중화, 오류 제어, 흐름 제어 수행
* 관련 장비 : 게이트 웨이



#### 세션 계층 

* 세션 : 두 이용자 사이의 연결, 해당 계층은 연결을 원하는 두 이용자 사이의 세션 설정 및 유지를 가능하게 한다.

* 송 수신 측 간의 관련성을 유지하고 대화 제어 담당

* 대화 구성 및 동기 제어, 데이터 교환 관리 기능을 한다

* 동기점은 오류가 있는 데이터의 회복을 위해 사용하는 것

  * 소동기점: 하나의 대화 단위 내에서 데이터의 전달을 제어하는 역할 (확인 신호 받지 않음)
  * 대동기점: 전송하는 각 데이터의 처음과 끝에 사용하여 전송하는 데이터 단위를 대화 단위로 구성하는 역할 (확인 신호 받음)

  

#### 표현 계층

* 응용 계층으로부터 받은 데이터를 세션 계층에 보내기 전에 통신에 적당한 형태로 변환하고, 세션 계층에서 받은 데이터는 응용 계층에 맞게 변환
* 서로 다른 데이터 표현 형태를 갖는 시스템 간의 상호 접속을 위해 필요한 계층
* 코드 변환, 데이터 암호화, 데이터 압축, 구문 검색, 정보 형식 변환, 문맥관리 기능



#### 응용 계층

* 사용자(응용 프로그램)가 OSI환경에 접근할 수 있도록 서비스 제공
* 응용 프로세스 간의 정보 교환, 전자 사서함, 파일 전송, 가상 터미널 등의 서비스 제공



---

### Section 177 네트워크 관련 장비

---



#### 네트워크 인터페이스 카드



#### 허브



#### 리피터



#### 브리지



#### 스위치



#### 라우터



#### 게이트웨이



----

### Section 178 TCP/IP

---



#### 프로토콜 (Protocol)

* `프로토콜` : 서로 다른 기기들 간의 데이터 교환을 원활하게 수행할 수 있도록 표준화시켜 놓은 통신 규약
* 기본요소
  * `구문(Syntax)` : 전송하고자 하는 데이터의 형식, 부호화, 신호 레벨 등을 규정
  * `의미(Semantic)` : 두 기기 간의 효율적이고 정확한 정보 전송을 위한 협조 사항과 오류 관리를 위한 제어 정보 규정
  * `시간(Timing)` : 두 기기 간의 통신 속도, 메시지의 순서 제어 규정
* 프로토콜의 기능 : 단편화와 재결합, 캡슐화, 흐름 제어, 오류 제어, 동기화, 순서 제어, 주소 지정, 다중화, 경로 제어, 전송 서비스 등



#### TCP/IP(Transmission Control Protocol/Internet Protocol)

* `TCP/IP` : 인터넷에 연결된 서로 다른 기종의 컴퓨터들이 데이터를 주고받을 수 있도록 하는 표준 프로토콜
* `TCP`
  * OSI 7계층 중 전송 계층에 해당
  * 가상 회선 방식을 기반으로 하는 연결형 서비스 제공 => 송 수신 측 간을 논리적으로 연결한 후 데이터를 전송하는 방식
  * 패킷의 다중화, 순서 제어, 오류 제어, 흐름 제어 기능 제공
* `IP`
  * OSI 7계층 중 네트워크 계층에 해당함
  * 데이터그램 방식을 기반으로 하는 비연결형 서비스 제공 => 송 수신측 간에 논리적 연결 없이 독립적으로 데이터 전송 ex) 데이터 그램
  * 패킷의 분해/조립, 주소 지정, 경로 선택 등의 기능 제공



#### TCP/IP의 구조

| OSI                             | TCP/IP               | 기능                                           |
| ------------------------------- | -------------------- | ---------------------------------------------- |
| 응용 계층, 표현 계층, 세션 계층 | 응용 계층            | 응용 프로그램 간의 데이터 송 수신 제공         |
| 전송 계층                       | 전송 계층            | 호스트간의 신뢰성 있는 통신 제공               |
| 네트워크 계층                   | 인터넷 계층          | 데이터 전송을 위한 주소 지정, 경로 설정을 제공 |
| 데이터 링크 계층, 물리 계층     | 네트워크 액세스 계층 | 실제 데이터(프레임)를 송 수신 하는 역할        |



#### 응용 계층의 주요 프로토콜

| 프로토콜                                 | 내용                                                         |
| ---------------------------------------- | ------------------------------------------------------------ |
| FTP(File Transfer Protocol)              | 컴퓨터와 컴퓨터 또는 컴퓨터와 인터넷 사이에서 파일을 주고 받을 수 있도록 하는 원격 파일 전송 프로토콜 |
| SMTP(Simple Mail Transfer Protocol)      | 전자 우편을 겨환하는 서비스                                  |
| TELNET                                   | 멀리 떨어져 있는 컴퓨터에 접속하여 자신의 컴퓨터처럼 사용할 수 있도록 해주는 서비스 </br> 프로그램을 실행하는 등 시스템 관리 작업을 할 수 있는 가상 터미널 기능 수행 |
| SNMP(Simple Network Management Protocol) | 도메인 네임을 IP주소로 매핑 하는 시스템                      |
| HTTP(HyperText Transfer Protocol)        | 월드 와이드 웹(WWW)에서 HTML문서를 송수신 하기 위한 표준 프로토콜 |



#### 전송 계층의 주요 프로토콜

| 프로토콜                            | 내용                                                         |
| ----------------------------------- | ------------------------------------------------------------ |
| TCP (Transmission Control Protocol) | 양방향 연결형 서비스를 제공함 </br>                          |
| UDP (User Datagram Protocol)        | 데이터 전송 전에 연결을 설정하지 않는 비연결형 서비스를 제공함 |
| RTCP (Real-Time Control Protocol)   | RTP 패킷의 전송 품질을 제어하기 위한 제어 프로토콜           |



#### 인터넷 계층의 주요 프로토콜

| 프로토콜                                   | 내용                                                         |
| ------------------------------------------ | ------------------------------------------------------------ |
| IP (Internet Protocol)                     |                                                              |
| ICMF (Internet Control Message Protocol)   |                                                              |
| IGMF (Internet Group Management Protocol)  | 멀티캐스트를 지원하는 호스트나 라우터 사이에서 멀티캐스트 그룹 유지를 위해 사용됨 |
| ARP (Address Resolution Protocol)          | 호스트의 IP주소를 호스트와 연결된 네트워크 접속 장치의 물리적 주소(MAC Address)로 바꿈 </br> (MAC Address : 랜 카드 제작사에서 부여한 고유 번호) |
| RARP (Reverse Address Resolution Protocol) | ARP와 반대로 물리적 주소를 IP주소로 변환하는 기능을 함       |



#### 네트워크 액세스 계층의 주요 프로토콜

| 프로토콜 | 내용                                                         |
| -------- | ------------------------------------------------------------ |
| Ethernet | CSMA/CD 방식의 LAN                                           |
| IEEE 802 | LAN을 위한 표준 프로토콜                                     |
| HDLC     | 비트 위주의 데이터 링크 제어 프로토콜                        |
| X.25     | 패킷 교환망을 통한 DTE와 DCE 간의 인터페이스를 제공하는 프로토콜 |
| RS-232C  | 공중 전화 교환망(PSTN)을 통한 DTE와 DCE 간의 인터페이스를 제공하는 프로토콜 |



---

### Section 179

---















---

### Section 180

---



#### 네트워크 

* `네트워크` : 두 대 이상의 컴퓨터를 전화선이나 케이블 등으로 연결하여 자원을 공유하는 것
* 다른 컴퓨터의 데이터, 프로그램, 주변장치, 인터넷 등을 공유하기 위해 사용
* 네트워크의 설치 구조는 장치들의 물리적 위치에 따라서 `성형`, `링형`, `버스형`, `계층형`, `망형`으로 나누어진다
* 네트워크는 사이트들이 분포되어 있는 지리적 범위에 따라 LAN과 WAN으로 분류된다.



#### 성형 (Star, 중앙 집중형)

* 중앙에 중앙 컴퓨터가 있고, 이를 중심으로 단말 장치들이 연결되는 중앙 집중식의 네트워크 구성 형태
* Point to Point 방식으로 회선 연결
* 단말장치의 추가와 제거가 쉽다.
* 하나의 단말장치가 고장나더라도 다른 단말 장치에 영향 x, 하지만 중앙 컴퓨터가 고장나면 전체 통신망 기능 정지



#### 링형 (Ring, 루프형)

* 컴퓨터와 단말장치들을 서로 이웃하는 것끼리 연결시킨 포인트 투 포인트 방식의 구성 형태이다.
* 단말장치의 추가/제거 및 기밀 보호가 어렵다.
* 각 단말장치엑서 전송 지연이 발생할 수 있다.
* 중계기의 수가 많아진다. 
* 데이터는 단방향 또는 양방향으로 전송할 수 있다.



#### 버스형 (Bus)

* 한 개의 통신 회선에 여러대의 단말장치가 연결되어 있는 형태
* 단말장치의 추가와 제거가 용이하다
* 단말장치가 고장나더라도 통신망 전체에 영향을 주지 않기 때문에 신뢰성을 높일 수 있다.
* 기밀 보장이 어렵다
* 통신 회선의 길이에 제한이 있다.



#### 계층형 (Tree, 분산형)

* 중앙 컴퓨터와 일정 지역의 단말장치까지는 하나의 통신 회선으로 연결시키고, 이웃하는 단말장치는 일정 지역내에 설치된 중간 단말장치로부터 다시 연결시키는 형태

* 중앙 컴퓨터 - 중간 단말장치 - 주변 단말장치 

* 분산 처리 시스템을 구성하는 방식

  #### 

#### 망형 (Mesh)

* 모든 지점의 컴퓨터와 단말 장치를 서로 연결한 형태, 노드의 연결성이 높다 
* 많은 단말장치로부터 많은 양의 통신을 필요로 하는 경우에 유리하다
* 통신 회성의 총 경로가 가장 길다
* 통신 회선 장애 시 다른 경로를 통하여 데이터를 전송할 수 있다.



#### 네트워크의 분류

* 근거리 통신망(LAN: Local Area Network)
  * 회사, 학교 연구소 등에서 비교적 가까운 거리에 있는 컴퓨터, 프린터, 저장장치 등과 같은 자원을 연결하여 구성함 
  * 주로 자원 공유를 목적으로 사용함
  * 사이트 간의 거리가 짧아 데이터 전송 속도 빠르고 에러 발생률 낮음 
  * 주로 버스형이나 링 형 사용
* 광대역 통신망(WAN: Wide Area Network)
  * 국가와 국가 또는 대륙과 대륙 등과 같이 멀리 떨어진 사이트들을 연결하여 구성함
  * 통신 속도가 느리고, 에러 발생률이 높음
  * 일정 지역에 있는 사이트들을 근거리 통신망으로 연결한 후, 각 근거리 통신망을 연결하는 방식 사용



#### LAN의 표준안

IEEE 802의 표준 규격

| 표준 규격 | 내용                                                         |
| --------- | ------------------------------------------------------------ |
| 802.1     | 전체의 구성, OSI 참조 모델과의 관계, 통신망 관리 등에 관한 규약 |
| 802.2     | 논리 링크 제어(LLC) 계층에 관한 규약                         |
| 802.3     | CSMA/CD 방식의 매체 접근 제어 계층에 관한 규약               |
| 802.4     | 토큰 버스 방식의 매체 접근 제어 계층에 관한 규약             |
| 802.5     | 토큰 링 방식의 매체 접근 제어 계층에 관한 규약               |
| 802.6     | 도시형 통신망 (MAN)에 관한 규약                              |
| 802.9     | 종합 음성/데이터 네트워크에 관한 규약                        |
| 802.11    | 무선 LAN에 관한 규약                                         |



802.11의 버전

* 업데이트 필요



#### NAT(Network Address Translation, 네트워크 주소 변환)

* 한개의 정식 IP주소에 대량의 가상 사설 IP 주소를 할당 및 연결
* 한 개의 IP 주소를 사요해서 외부에 접속할 수 있는 노드는 어느 시점에서 한개로 제한되는 문제가 있지만 IP 마스커레이드를 이용하여 해결
  * IP 마스커레이드 : 리눅스의 NAT 기능, 리눅스 서버를 통해 다른 네트워크에 접속할 수 있도록 해줌





